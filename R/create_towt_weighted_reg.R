#' Create weighted linear regression models for energy use data using time-of-week and outside air temperature as independent variables.
#'
#' \code{This function applies the hyperparamter, 'Weighting Factor', to the linear regressions generated by the function 'fit_TOWT_reg'.
#' It is a utility function for another kWMV function: 'model_with_TOWT'.
#' This function is adapted from work by LBNL: \url{https://lbnl-eta.github.io/RMV2.0/}}
#'
#' @param time_col time column of training data
#' @param eload_col eload column of training data
#' @param temp_col temp column of training data
#' @param pred_time_col time column of prediction data
#' @param pred_temp_col temp column of prediction data
#' @param timescale_days Numeric correspond to the timescale for weighting function.Default: NULL.
#' Change to improve accuracy of short term models.
#' @param interval_minutes Numeric for the interval period. Default: 15.
#' @param has_temp_knots_defined Boolean specifying whether the temp_knots are pre-defined or will be calculated by the algorithm
#' @param run_temperature_model Boolean specifying whether temperature should or should not be used in regression modeling.
#' @param equal_temp_segment_points Boolean specifying structure of temperature segments: equal number of points vs. equal segment length
#' @param temp_segments Numeric for number of temperature segments. Default: 6
#' @param temp_knots_value Vector specifying manually defined temperature knots.
#' @param has_operating_modes Boolean specifying whether the energy use profile has varying operating modes.
#' @param train_operating_mode_data dataframe with indicator variables for the various operating modes present in the model training period.
#' @param pred_operating_mode_data dataframe with indicator variables for the various operating modes present in the mdoel prediction period.
#' @param categories vector specifying names of the operating modes present.
#'
#' @return Weighted baseline and prediction matrices
#'
#' @export


create_TOWT_weighted_reg <- function(time_col, eload_col, temp_col,
                          pred_time_col, pred_temp_col,
                          timescale_days = timescale_days,
                          interval_minutes=interval_minutes,
                          has_temp_knots_defined=has_temp_knots_defined,
                          run_temperature_model=run_temperature_model,
                          equal_temp_segment_points = equal_temp_segment_points,
                          temp_segments= temp_segments,
                          temp_knots_value = temp_knots_value,
                          has_operating_modes = has_operating_modes,
                          train_operating_mode_data = train_operating_mode_data,
                          pred_operating_mode_data = pred_operating_mode_data,
                          categories = categories) {

  # To determine num_model_runs
  num_points <- length(eload_col)
  t0 <- min(time_col, na.rm = TRUE)
  t1 <- max(time_col, na.rm = TRUE)

  delta_t <- as.numeric(difftime(t1, t0, units = "days"))
  num_segments <- max(1, ceiling(delta_t / timescale_days))
  segment_width <- (num_points - 1) / num_segments
  point_list <- floor(sort(num_points - segment_width * (0 : num_segments)) +
                        0.001)

  if (is.null(timescale_days)) {
    num_model_runs <- 1
  } else {
    num_model_runs <- max(1, length(point_list))
  }

  # Creating weighting matrices for training and prediction data

  train_matrix <- matrix(NA, nrow = num_model_runs,
                         ncol = length(time_col))
  pred_matrix <- matrix(NA, nrow = num_model_runs,
                        ncol = length(pred_time_col))

  train_weight_matrix <- matrix(NA, nrow = num_model_runs,
                                ncol = length(time_col))
  weight_matrix <- matrix(NA, nrow = num_model_runs,
                          ncol = length(pred_time_col))

  for (row_index in 1 : num_model_runs) {

    tcenter <- time_col[point_list[row_index]]
    t_diff <- as.numeric(difftime(tcenter, time_col, units = "days"))
    t_diff_pred <- as.numeric(difftime(tcenter, pred_time_col, units = "days"))

    if (is.null(timescale_days)) {
      weight_vec <- rep(1, length(eload_col))
    } else {
      weight_vec <- timescale_days ^ 2 /
        (timescale_days ^ 2 + t_diff ^ 2)
    }

    if (is.null(timescale_days)) {
      weight_vec_pred <- rep(1, length(pred_time_col))
    } else {
      weight_vec_pred <- timescale_days ^ 2 /
        (timescale_days ^ 2 + t_diff_pred ^ 2)
    }

    # For temperature segments and corresponding knots
    if (has_temp_knots_defined) {
      temp_knots <- temp_knots_value
    }else {
      temp0 <- min(temp_col, na.rm = TRUE)
      temp1 <- max(temp_col, na.rm = TRUE)
      delta_temp <- temp1 - temp0

      if (equal_temp_segment_points) {
        temp_segment_width <- num_points / temp_segments
        temp_points <- floor(sort(length(temp_col) - temp_segment_width *
                                    (0 : temp_segments)) + 0.001)
        temp_ordered <- sort(temp_col, decreasing = F)
        temp_knots <- temp_ordered[temp_points]
      }else {
        temp_segment_width <- delta_temp / temp_segments
        temp_knots <- floor(sort(max(temp_col) - temp_segment_width *
                                   (0 : temp_segments)) + 0.001)
      }
    }

    reg_out <- fit_TOWT_reg(time_col, eload_col, temp_col,
                             pred_time_col, pred_temp_col,
                             temp_knots = temp_knots, weight_vec = weight_vec,
                             interval_minutes = interval_minutes,
                             run_temperature_model = run_temperature_model,
                             has_operating_modes = has_operating_modes,
                             train_operating_mode_data = train_operating_mode_data,
                             pred_operating_mode_data = pred_operating_mode_data,
                             categories = categories)

    train_out <- reg_out$training
    train_matrix[row_index, ] <- train_out$training_load_pred
    train_weight_matrix[row_index, ] <- weight_vec
    training_model_occ_period <- reg_out$lm_results_occ_period
    training_model_unocc_period <- reg_out$lm_results_unocc_period

    pred_out <- reg_out$predictions
    pred_matrix[row_index, ] <- pred_out$pred_vec
    weight_matrix[row_index, ] <- weight_vec_pred
  }

  # Applying th weighting matrix to baseline and prediction data

  final_baseline <- apply(pred_matrix * weight_matrix, 2, sum) /
    apply(weight_matrix, 2, sum)
  final_train_baseline <- apply(train_matrix * train_weight_matrix, 2, sum) /
    apply(train_weight_matrix, 2, sum)

  output <- NULL
  output$time_vec <- pred_time_col
  output$baseline <- final_baseline
  output$pred_matrix <- pred_matrix
  output$weight_matrix <- weight_matrix
  output$train_time <- time_col
  output$train_baseline <- final_train_baseline
  output$temp_knots <- temp_knots
  output$training_model_occ_period <- training_model_occ_period
  output$training_model_unocc_period <- training_model_unocc_period

  return(output)
}
